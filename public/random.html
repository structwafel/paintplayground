    <script>
        const canvas = document.getElementById('colorGrid');
        const ctx = canvas.getContext('2d');
        const cellSize = 10;
        const gridWidth = 100;
        const gridHeight = 100;
        const colors = new Array(gridWidth * gridHeight).fill('grey');

        canvas.width = 1000;
        canvas.height = 1000;

        let offsetX = 0;
        let offsetY = 0;

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const startX = Math.floor(offsetX / cellSize);
            const startY = Math.floor(offsetY / cellSize);
            const endX = Math.min(startX + Math.ceil(canvas.width / cellSize), gridWidth);
            const endY = Math.min(startY + Math.ceil(canvas.height / cellSize), gridHeight);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const color = colors[y * gridWidth + x];
                    ctx.fillStyle = color;
                    ctx.fillRect((x * cellSize) - offsetX, (y * cellSize) - offsetY, cellSize, cellSize);
                }
            }
        }
        function handleScroll(event) {
            if (event.shiftKey || (Math.abs(event.deltaX) > Math.abs(event.deltaY))) {
                // Horizontal scrolling
                offsetX = Math.max(0, Math.min(gridWidth * cellSize - canvas.width, offsetX + event.deltaX));
            } else {
                // Vertical scrolling
                offsetY = Math.max(0, Math.min(gridHeight * cellSize - canvas.height, offsetY + event.deltaY));
            }
            drawGrid();
        }
        let isMouseDown = false;

        function handleMouseDown(event) {
            isMouseDown = true;
            handleColoring(event);
        }

        function handleMouseMove(event) {
            if (isMouseDown) {
                handleColoring(event);
            }
        }

        function handleMouseUp(event) {
            isMouseDown = false;
        }
        function handleColoring(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left + offsetX;
            const y = event.clientY - rect.top + offsetY;
            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const index = cellY * gridWidth + cellX;

            // Change the color of the clicked cell
            colors[index] = selectedColor; // You can change this to any color or logic you want
            drawGrid();

            // Send the updated color to the server
            const data = new Uint8Array(8);
            const view = new DataView(data.buffer);

            view.setBigUint64(0, BigInt(index << 4) | BigInt(colorMapping[selectedColor]), true); // Assuming 1 corresponds to 'red'
            socket.send(data.buffer);
        }
        canvas.addEventListener('wheel', handleScroll);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp); // To handle the case when the mouse leaves the canvas

        drawGrid();




        function connect() {
            socket = new WebSocket(websocketUrl);
            socket.binaryType = 'arraybuffer';
            socket.onopen = function () {
                console.log('WebSocket connection established');
            };

            socket.onmessage = function (event) {
                if (event.data instanceof ArrayBuffer) {
                    console.log('Received binary message');
                    const view = new DataView(event.data);
                    const messageType = view.getUint8(0);
                    console.log('Received chunk updates');
                    switch (messageType) {
                        // entire chunk (download), this is just array of colors
                        case 1:
                            for (let i = 1; i < view.byteLength; i++) {
                                const color = colorFromNumber(view.getUint8(i));
                                colors[i - 1] = color;
                            }
                            drawGrid();
                            break;
                        // chunk updates
                        case 2:
                            for (let i = 1; i < view.byteLength; i += 8) {
                                const packedValue = view.getBigUint64(i, true);
                                const index = Number(packedValue >> 4n);
                                const colorNumber = Number(packedValue & 0xFn);
                                const color = colorFromNumber(colorNumber);
                                colors[index] = color;
                            }
                            drawGrid();
                            break;
                        // too many chunks were loaded, so we cannot do anything.
                        // message user that server is busy
                        case 3:
                            // show alert
                            alert('Server is busy, try again later');
                            break;
                    }
                }else{
                    console.log('Received text message');
                    console.log(event.data);
                }
            };
            socket.onclose = function () {
                console.log('WebSocket connection closed. Reconnecting...');
                setTimeout(connect, 1000);
            };
        }
        connect()
    </script>